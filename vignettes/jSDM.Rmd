---
title: "Get started with jSDM"
output:
  bookdown::html_document2:
    #base_format: rmarkdown::html_vignette
    #highlight: tango
    number_sections: true
    toc: true
    #toc_float: true
    fig_caption: yes
link-citations: yes
bibliography: bib/biblio-jSDM.bib
biblio-style: bib/jae.bst
csl: bib/journal-of-applied-ecology.csl
pkgdown:
  as_is: true
vignette: >
 %\VignetteEngine{knitr::rmarkdown}
 %\VignetteIndexEntry{Get started with jSDM}
 %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	fig.align = "center",
	fig.width = 6, fig.height = 6,
	cache = FALSE,
	collapse = TRUE,
	comment = "#>",
	highlight = TRUE
)
```

@Warton2015

```{r test, cache=TRUE}
#==============================================
# jSDM_probit_block()
# Example with simulated data
#==============================================

#=================
#== Load libraries
library(jSDM)

#==================
#== Data simulation

#= Number of sites
nsite <- 300
#= Set seed for repeatability
seed <- 1234
set.seed(seed)
#= Number of species
nsp<- 100
#= Number of latent variables
n_latent <- 2
#= Ecological process (suitability)
x1 <- rnorm(nsite,0,1)
x2 <- rnorm(nsite,0,1)
X <- data.frame(Int=rep(1,nsite),x1=x1,x2=x2)
W <- cbind(rnorm(nsite,0,1),rnorm(nsite,0,1))
data <- cbind (X,W)
beta.target <- t(matrix(runif(nsp*ncol(X),-2,2), byrow=TRUE, nrow=nsp))
l.zero <- 0
l.diag <- runif(2,0,2)
l.other <- runif(nsp*n_latent-3,-2,2)
lambda.target <- t(matrix(c(l.diag[1],l.zero,l.other[1],l.diag[2],l.other[-1]), byrow=T, nrow=nsp))
param.target <- rbind(beta.target,lambda.target)
Valpha.target <- 0.5
V <- 1
alpha.target <- rnorm(nsite,0,sqrt(Valpha.target))
probit_theta <- as.matrix(X) %*% beta.target + W %*% lambda.target + alpha.target
e <- matrix(rnorm(nsp*nsite,0,sqrt(V)),nsite,nsp)
Z_true <- probit_theta + e
visits <- matrix(1,nsite,nsp)
#comment on fait pour prendre en compte le nombre de visites ?
Y <- matrix (NA, nsite,nsp)
for (i in 1:nsite){
  for (j in 1:nsp){
    if ( Z_true[i,j] > 0) {Y[i,j] <- 1}
    else {Y[i,j] <- 0}
  }
}

#==================================
#== Site-occupancy model

mod_jSDM_probit_block <- jSDM_probit_block(
	presence_site_sp=Y ,
	site_suitability=~x1+x2,
	site_data=X[,-1], n_latent=2,
	burnin=1000, mcmc=1000, thin=1,
	alpha_start=0, beta_start=0,
	lambda_start=0, W_start=0,
	V_alpha_start=1, shape=0.5, rate=0.0005,
	mu_beta=0, V_beta=1.0E6,
	mu_lambda=0, V_lambda=10,
	seed=1234, verbose=1
)

# ===================================================
# Result analysis
# ===================================================

#==========
#== Outputs

#= Parameter estimates

## alpha
summary(mod_jSDM_probit_block$mcmc.alpha)
pdf(file="Posteriors_alpha_jSDM_probit_block.pdf")
plot(mod_jSDM_probit_block$mcmc.alpha)
plot(alpha.target,summary(mod_jSDM_probit_block$mcmc.alpha)[[1]][,"Mean"],
     ylab ="alpha.estimated")
abline(a=0,b=1,col='red')
dev.off()

## Valpha
summary(mod_jSDM_probit_block$mcmc.Valpha)
pdf(file="Posteriors_Valpha_jSDM_probit_block.pdf")
par(mfrow=c(1,2))
coda::traceplot(mod_jSDM_probit_block$mcmc.Valpha)
coda::densplot(mod_jSDM_probit_block$mcmc.Valpha)
abline(v=Valpha.target,col='red')
dev.off()


## beta_j
summary(mod_jSDM_probit_block$mcmc.sp$sp_1[,1:ncol(X)])
pdf(file="Posteriors_beta_jSDM_probit_block.pdf")
par(mfrow=c(ncol(X),2))
for (j in 1:nsp) {
  for (p in 1:ncol(X)) {
    coda::traceplot(coda::as.mcmc(mod_jSDM_probit_block$mcmc.sp[[paste0("sp_",j)]][,p]))
    coda::densplot(coda::as.mcmc(mod_jSDM_probit_block$mcmc.sp[[paste0("sp_",j)]][,p]), 
    main = paste(colnames(mod_jSDM_probit_block$mcmc.sp[[paste0("sp_",j)]])[p],", species : ",j))
    abline(v=beta.target[p,j],col='red')
  }
}
dev.off()

## lambda_j
summary(mod_jSDM_probit_block$mcmc.sp$sp_1[,(ncol(X)+1):(ncol(X)+n_latent)])
summary(mod_jSDM_probit_block$mcmc.sp$sp_2[,(ncol(X)+1):(ncol(X)+n_latent)])
pdf(file="Posteriors_lambda_jSDM_probit_block.pdf")
par(mfrow=c(n_latent*2,2))
for (j in 1:nsp) {
  for (l in 1:n_latent) {
    coda::traceplot(coda::as.mcmc(mod_jSDM_probit_block$mcmc.sp[[paste0("sp_",j)]][,ncol(X)+l]))
    coda::densplot(coda::as.mcmc(mod_jSDM_probit_block$mcmc.sp[[paste0("sp_",j)]][,ncol(X)+l]), 
    main=paste(colnames(mod_jSDM_probit_block$mcmc.sp[[paste0("sp_",j)]])[ncol(X)+l],",
    species : ",j))
    abline(v=lambda.target[l,j],col='red')
  }
}
dev.off()

## W latent variables
pdf(file="Posteriors_lv_jSDM_probit_block.pdf")
par(mfrow=c(1,1))
for (l in 1:n_latent) {
summary(mod_jSDM_probit_block$mcmc.latent[[paste0("lv_",l)]])
plot(mod_jSDM_probit_block$mcmc.latent[[paste0("lv_",l)]])
plot(W[,l],summary(mod_jSDM_probit_block$mcmc.latent[[paste0("lv_",l)]])[[1]][,"Mean"],
main = paste0("Latent variable W_", l))
abline(a=0,b=1,col='red')
}
dev.off()

## Deviance
summary(mod_jSDM_probit_block$mcmc.Deviance)
plot(mod_jSDM_probit_block$mcmc.Deviance)

#= Predictions
pdf(file="Pred-Init.pdf")
## probit_theta
summary(mod_jSDM_probit_block$probit_theta_pred)
par(mfrow=c(1,1))
plot(probit_theta,mod_jSDM_probit_block$probit_theta_pred)
abline(a=0,b=1,col='red')
## Z
summary(mod_jSDM_probit_block$Z_latent)
plot(Z_true,mod_jSDM_probit_block$Z_latent)
abline(a=0,b=1,col='red')
dev.off()

```

# References